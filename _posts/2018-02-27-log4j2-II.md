---
layout: post
title: "Log4j2 -- II"
categories: Log4j2
tag: Java-Libs
---
> `Log4j2-v2.10.0-User's Gudie`

## 4. 配置

将日志请求插入到应用程序代码中需要进行相当多的计划和努力。观察显示大约4％的代码专用于日志记录。因此，即使大小适中的应用程序也会在其代码中嵌入数千条日志语句。根据他们的编号，无需手动修改的管理这些日志语句变得势在必行。

Log4j 2的配置可以通过以下四种方式完成：

1. 通过以XML，JSON，YAML或properties格式编写的配置文件。
2. 以编程方式，通过创建ConfigurationFactory和Configuration实现。
3. 以编程方式，通过调用Configuration接口中的API将组件添加到默认配置。
4. 以编程方式，通过调用内部Logger类的方法。

本页主要关注通过配置文件配置Log4j。有关以编程方式配置Log4j的信息，请参阅Extending Log4j2和Programmatic Log4j Configuration。

请注意与Log4j 1.x不同的是，Log4j2的公共API无用于添加，修改或删除appender和filter或以任何方式操作配置的方法。

### 4.1 自动配置

Log4j具有在初始化期间自动配置的能力。当Log4j启动时，它将找到所有ConfigurationFactory并按照从高到低的加权顺序排列它们。Log4j包含四个ConfigurationFactory实现：一个用于JSON，一个用于YAML，一个用于property，一个用于XML。

1. Log4j将检查log4j.configurationFile系统属性，如果已设置，则会尝试使用与文件扩展名匹配的ConfigurationFactory加载配置。
2. 如果没有设置系统属性，则properties ConfigurationFactory将在类路径中查找log4j2-test.properties文件。
3. 如果没有找到这样的文件，则YAML ConfigurationFactory将在类路径中查找log4j2-test.yaml或log4j2-test.yml。
4. 如果没有找到这样的文件，则JSON ConfigurationFactory将在类路径中查找log4j2-test.json或log4j2-test.jsn。
5. 如果没有找到这样的文件，则XML ConfigurationFactory将在类路径中查找log4j2-test.xml。
6. 如果无法找到test文件，则properties ConfigurationFactory将在类路径中查找log4j2.properties。
7. 如果找不到properties文件，则YAML ConfigurationFactory将在类路径中查找log4j2.yaml或log4j2.yml。
8. 如果找不到YAML文件，则JSON ConfigurationFactory将在类路径中查找log4j2.json或log4j2.jsn。
9. 如果找不到JSON文件，则XML ConfigurationFactory将尝试在类路径中找到log4j2.xml。
10. 如果找不到配置文件，将使用DefaultConfiguration。这将导致日志记录输出到控制台。

一个使用log4j的名为MyApp的示例应用程序可以用来说明如何完成。

```java
import com.foo.Bar;

// Import log4j classes.
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;

public class MyApp {

    // Define a static logger variable so that it references the
    // Logger instance named "MyApp".
    private static final Logger logger = LogManager.getLogger(MyApp.class);

    public static void main(final String... args) {

        // Set up a simple configuration that logs on the console.

        logger.trace("Entering application.");
        Bar bar = new Bar();
        if (!bar.doIt()) {
            logger.error("Didn't do it.");
        }
        logger.trace("Exiting application.");
    }
}
```

MyApp首先导入log4j相关的类，然后定义了一个名为MyApp的静态logger变量，该logger名恰好是这个类的完全限定名。

MyApp使用com.foo包中定义的Bar类。

```java
package com.foo;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;

public class Bar {
  static final Logger logger = LogManager.getLogger(Bar.class.getName());

  public boolean doIt() {
    logger.entry();
    logger.error("Did it again!");
    return logger.exit(false);
  }
}
```

如果找不到配置文件，Log4j将提供默认配置。DefaultConfiguration类中提供的默认配置将设置为：

- 连接到root logger的ConsoleAppender。
- 将PatternLayout设置为连接到ConsoleAppender，并设置模式为`%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n`。

请注意，默认情况下，Log4j将root logger设置为Level.ERROR。

MyApp的输出将类似于：

```
17:13:01.540 [main] ERROR com.foo.Bar - Did it again!
17:13:01.540 [main] ERROR MyApp - Didn't do it.
```

如前所述，Log4j首先尝试通过配置文件进行配置，一个类似于默认配置的配置文件如下所示：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="WARN">
  <Appenders>
    <Console name="Console" target="SYSTEM_OUT">
      <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
    </Console>
  </Appenders>
  <Loggers>
    <Root level="error">
      <AppenderRef ref="Console"/>
    </Root>
  </Loggers>
</Configuration>
```

一旦这个文件被放置在类路径并命名为log4j2.xml，你将得到与上面列出的结果相同的结果。将root级别更改为trace将导致类似于以下结果：

```
17:13:01.540 [main] TRACE MyApp - Entering application.
17:13:01.540 [main] TRACE com.foo.Bar - entry
17:13:01.540 [main] ERROR com.foo.Bar - Did it again!
17:13:01.540 [main] TRACE com.foo.Bar - exit with (false)
17:13:01.540 [main] ERROR MyApp - Didn't do it.
17:13:01.540 [main] TRACE MyApp - Exiting application.
```

请注意，使用默认配置时，status记录被禁用。

### 4.2 可加性

也许希望清除除com.foo.Bar之外的所有TRACE输出。简单的更改日志级别**不能**完成任务。相反，需要将新的Logger定义添加到配置中：

```xml
<Logger name="com.foo.Bar" level="TRACE"/>
<Root level="ERROR">
  <AppenderRef ref="STDOUT">
</Root>
```

使用此配置，将记录所有来自com.foo.Bar的所有日志事件，而所有其他组件将仅记录error事件。

在前面的例子中，com.foo.Bar中的所有事件仍然写入控制台。这是因为尽管com.foo.Bar的Logger没有任何appender配置，而它的父类拥有。其实就是下面的配置：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="WARN">
  <Appenders>
    <Console name="Console" target="SYSTEM_OUT">
      <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
    </Console>
  </Appenders>
  <Loggers>
    <Logger name="com.foo.Bar" level="trace">
      <AppenderRef ref="Console"/>
    </Logger>
    <Root level="error">
      <AppenderRef ref="Console"/>
    </Root>
  </Loggers>
</Configuration>
```

将产生如下输出：

```
17:13:01.540 [main] TRACE com.foo.Bar - entry
17:13:01.540 [main] TRACE com.foo.Bar - entry
17:13:01.540 [main] ERROR com.foo.Bar - Did it again!
17:13:01.540 [main] TRACE com.foo.Bar - exit (false)
17:13:01.540 [main] TRACE com.foo.Bar - exit (false)
17:13:01.540 [main] ERROR MyApp - Didn't do it.
```

请注意，来自com.foo.Bar的trace消息出现了两次。这是因为首先使用了与logger com.foo.Bar相关联的appender，它将第一个消息实例写入控制台。接下来，引用com.foo.Bar的父类，即本例中的root记录器，然后日志事件被传递给root的appender并写入控制台，产生了第二个消息实例。这被称为可加性。虽然additivity可以是一个非常方便的功能（如前面的示例，无需配置appender引用），但在许多情况下此行为被认为是不可取的。因此可以通过将Logger上的additivity属性设置为false以禁用它：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="WARN">
  <Appenders>
    <Console name="Console" target="SYSTEM_OUT">
      <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
    </Console>
  </Appenders>
  <Loggers>
    <Logger name="com.foo.Bar" level="trace" additivity="false">
      <AppenderRef ref="Console"/>
    </Logger>
    <Root level="error">
      <AppenderRef ref="Console"/>
    </Root>
  </Loggers>
</Configuration>
```

一旦日志事件到达一个将其可加性设置为false的Logger，则不管该Logger的父记录器可加性设置为何，该事件都不会传递给它的任何父记录器。