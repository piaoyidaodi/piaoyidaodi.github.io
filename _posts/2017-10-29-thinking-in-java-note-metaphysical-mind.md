---
layout: post
title: "Java编程思想--玄学思想"
categories: Thinking-In-Java-Note
tag: Core-Java
---
> `Thinking In java`中一些玄学思想。

## Thinking In Java

1. 人们所能够解决的问题的复杂性直接取决于**抽象的类型和质量**。

2. 对象就是：**服务的提供者，具有高内聚性**。

3. 对象使得你可以通过概念将**数据和功能**封装到一起，因此可以对问题空间的观念给出恰当的表示，而不用受制于必须使用底层语言。

4. 一个基类包含其所有导出类所**共享的特性和行为**。

5. 数据存放区：
- 栈：对象引用（指针、句柄）、基本数据类型(`boolean,char,byte,short,int,long,float,double`)，等
- 堆：对象，等
- 非RAM存储：流对象、持久化对象，等

6. 创建一个对象数组时，实际创建了一个引用数组，并且每个引用都会被自动初始化为一个特定值`null`；存放基本类型的数组，编译器会将这类数组所占内存全部**置零**。

7. 构造器是一种特殊类型的方法，因为它没有返回值，且与返回值为`void`方法明显不同。在`Java`中，初始化与创建绑定在一起，两者不能分离。

8. `static`方法大量出现在代码中，就该重新考虑自己的设计了。

9. 无法阻止自动初始化的进行，它将在构造器被调用之前发生。

10. 多态通过分离做什么和怎么做，从另一个角度将接口和实现分离开。

11. rt.jar中rt的意思为runtime。

## Algorithm and Data Structure In Java

### 数组

类的用户通过类接口的方式与类连接。由于类的字段经常是私有的，所以当我们讨论接口的时候，经常指的是类方法。

有序数组vs无序数组：
- 优点：查找元素比无序数组快多了。
- 缺点：插入操作后所有靠后的数据都需要移动以腾开空间，速度较慢
- 共同缺点：删除速度较慢，因为都需要补洞。

大O表示法的实质不是对运行时间给出实际值，而是给出了**运行时间受数据量的影响程度**。

### 简单排序--冒泡、选择、插入

在许多算法中，**有些条件在算法执行过程中是不变的**，这些条件称为不变性。认识不变性对理解算法是有用的，也可以通过反复检查不变性是否为真，进行程序的调试。

插入排序在这几类基础算法中是最好的一种，虽然仍需要O(N<sup>2</sup>)的时间，但是在一般情况下，比冒泡排序快1倍，比选择排序还要快一点。经常被用在较复杂排序算法的最后阶段，如快速排序。

**局部有序在冒泡排序和选择排序中是不会出现的。在这两个算法中，一组数据在某个时刻是完全有序的；在插入排序中，一组数据仅仅是局部有序的。**

不变性：
- 冒泡排序：冒泡排序中不变性指，外层循环out（由大到小）右边的所有数据已完成了排序。
- 选择排序：选择排序中不变性指，外层循环out（有小到大）左边的所有数据已完成了排序。
- 插入排序：插入排序中不变性指，在将temp位置的项目插入后，比outer变量下标号小的数据项都是局部有序的。

效率：
- 冒泡排序：冒泡排序的比较和交换操作次数均与N<sup>2</sup>成正比，因此需要O(N<sup>2</sup>)时间级别。
- 选择排序：选择排序的比较与N<sup>2</sup>成正比，交换操作次数小于N，因此是O(N<sup>2</sup>)时间级别，但是由于更少的交换次数，因此在数据量较大时，较冒泡排序有更高的效率。
- 插入排序：插入排序在随机顺序下的数据也需要O(N<sup>2</sup>)的时间级；对于已经基本有序的数据来说，插入排序几乎只需要O(N)的时间级别。

### 栈和队列

栈为后进先出（LIFO）的数据结构。大部分的微处理器使用基于栈的体系结构，当调用一个方法时，把它的返回地址和参数压入栈，当方法结束返回时数据出栈。栈通常的容量比较小。

栈通常用于解析某种类型的文本串，通常文本串是用计算机语言写的代码行，而解析他的程序就是编译器。

循环队列通过将队头队尾的指针绕回到数组开始的位置，避免队列不满却不能插入新数据项的问题。

双端队列就是一个两端都是结尾的队列，每一端都可以插入数据项和移除数据项。

优先级队列通常使用堆实现。在优先级队列中，数据项按照关键字的使用权重有序排列，使用权重最大的总是在队头，数据项插入的时候会按照顺序插入到合适的位置以确保队列的顺序。

效率：
- 栈中数据项入栈和出栈的时间复杂度都为常数O(1)，也就是说栈操作所消耗的时间不依赖于栈中数据项的个数。
- 队列中插入数据项和移除数据项的时间复杂度均为O(1)。
- 优先级队列（数组实现），插入操作需要O(N)，删除需要O(1)。

中缀表达式为书写算术表达式，操作符在操作数中间；后缀表达式为操作符在操作数后面的表达式。

### 链表

链表可以替代数组，作为其他存储结构的基础。除非需要频繁的访问下标，否则在很多使用数组的地方都可以使用链表。链表相比于数组更加强调数据之间的关系，而不是数据之间的位置。

双端链表，拥有对最后一个链接点的引用，可以在链表头和尾直接插入链接点。

数据抽象（ADT）：是一种考虑数据结构的方式，着重于做了什么，而忽略怎么做。**在面向对象编程中，一个抽象数据类型是一个类，且不考虑他的实现。它是对类中数据的描述和能够在数据上执行的一系列操作以及如何使用这些操作的说明。**类的用户只会被告知可以如何使用，而不知道如何实现。

效率：
- 在表头插入和删除速度很快，仅需要改变一两个引用的值，花费时间为O(1)。
- 平均起来，查找，删除和在指定位置插入都需要搜索链表中一半的链接点，需要O(N)次比较。但是因为链表不需要移动任何数据，因此比数组快，特别是复制时间远大于比较时间时。
- 链表较数组相比，可以使用更多的内存。