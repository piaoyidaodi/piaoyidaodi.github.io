---
layout: post
title: "Java编程思想--关键概念III"
categories: Thinking-In-Java-Note
tag: Core-Java
---
> `java`中一些重要的概念，**集合、异常、字符串、类型信息**等。

## 1. 持有对象

### 1.1 基本概念

通过使用泛型，可以在**编译期**防止将错误类型的对象放置到容器中。

容器的作用是保存对象，可以划分为两个概念：`Collection`和`Map`。`Collection`接口概括了序列的概念，即一种存放一组对象的方式。

`Arrays.asList()`方法接受**一个数组或一个逗号分割的元素列表**，并将其转化为一个List对象。由于其底层表示的是数组，因此不能调整尺寸。使用该方法时需要进行显式类型参数说明，即`Arrays.<T>asList()`以明确实际的目标类型应该是什么。

`Collections.addAll()`方法接受**一个Collection对象，以及一个数组或一个逗号分割的元素列表**，将元素添加入Collection中。

### 1.2 集合特点

#### 1.2.1 List

有两种基础类型的List：
- `ArrayList`：擅长随机访问，在List中插入和移除元素较慢。
- `LinkedList`：擅长在List中进行插入和删除操作，提供了优化的顺序访问，在随机访问方面较慢。

迭代器是一个对象，它遍历并选择序列中的对象；迭代器是一个轻量级的对象，创建它的代价很小。通过迭代器将遍历序列的操作与序列底层的结构分离，统一了容器的访问方式。
- 使用方法iterator()要求容器返回一个Iterator。Iterator将准备好返回序列的第一个元素。
- 使用next()获取序列中的下一个元素。
- 使用hasNext()检查序列中是否还有元素。
- 使用remove()将迭代器新近返回的元素删除。

ListIterator是Iterator的子类型，只能用于各种List的访问。它可以双向移动，使用set()方法替换它访问过的最后一个元素。可以通过调用listIterator()方法产生一个指向List开始初的ListIterator，通过设定索引获取指向特定位置的ListIterator。

#### 1.2.2 Set

有三个基础类型的Set：
- `HashSet`使用了散列函数。
- `TreeSet`将元素存储在红黑树中。
- `LinkedHashSet`使用散列函数，但又使用了链表维护插入顺序。

### 1.3 Collection和Iterator

Collection是描述所有序列容器的共性根接口，可以被认为是一个“附属接口”，因为要代表其他若干个接口的共性而出现的接口。另外其拥有默认实现AbstractCollection。

使用接口描述的原因是它可以使我们能够创建更加通用的代码，通过针对接口而非具体的实现来编写代码，代码可应用于更多的对象类型。但Java与C++一致**使用Iterator作为容器的共性**。

### 1.4 foreach和迭代器

foreach语法主要用于数组，但可以应用于任何Collection对象。一个任何实现了Iterable接口方法的类，都可以放置于foreach语句中。

foreach语法可用于数组或其他Iterable，但是数组并不是一个Iterable，且不会发生自动包装，必须手动转换。

## 2. 异常

### 2.1 基本概念

异常情形是指阻止当前方法或作用域继续执行的问题。异常与普通问题相区分：
- 普通问题指，当前环境下能得到足够的信息，总能得到处理的错误。
- 异常情形，当前环境下无法获得必要的信息来解决问题。

当抛出异常后，会有几件事随之发生。
- 首先，使用new在堆上创建异常对象。
- 当前执行路径被终止，并且从当前环境中弹出对异常对象的引用。
- 此时异常处理机制接管程序，并开始寻找异常处理程序继续执行程序。异常处理程序的任务是将程序从错误状态中恢复，是程序要么换一种方式运行，要么继续运行下去。

所有标准异常类都有**两个构造器**：一个是默认构造器；一个是接受字符串作为参数的构造器，以便放入相关信息到异常对象。异常对象的引用被传递给throw。能抛出任何Throwable对象，他是所有异常类型的根类。

异常处理理论有两种基本模式：
- **终止模型（C++，Java等主流语言支持）**：将假设错误非常关键，以至于程序无法返回到异常发生的地方继续执行，一旦异常被抛出，就表明错误已无法挽回，也不能回来继续执行。
- **恢复模型**：异常处理程序的工作时修正错误，然后重新尝试调用出问题的方法，并认为第二次能成功。

要自定义异常类，必须从已有的异常类继承，最好是选择意思相近的异常类继承。

Java使用异常说明（throws关键字后接一个所有潜在的异常类型列表）声明该方法可能抛出的异常。代码必须与异常说明保持一致，如果方法里的代码产生了异常却没有进行处理，编译器会发现这个问题并提醒你，要么处理这个异常，要么就在异常说明里表明此方法将产生异常。

### 2.2 异常处理

**异常分类**

Exception类是所有异常的基类，它是Throwable的子类。其中`printStackTrace()`方法所提供的信息可以通过`getStackTrace()`的方法来直接访问，这个方法将返回一个由栈轨迹中元素所构成的数组，其中每一个元素都表示栈中的一帧，元素0为栈顶元素，并且是调用序列中的最后一个方法调用（即Throwable被创建和抛出的地方）。

所有的Throwable的子类在构造器中都可以接受一个cause对象作为参数，即原始异常，来把原始异常传递给新的异常，使得异常链可以追踪到异常最初发生的位置。只有三种最基本的异常：**Error（虚拟机报告系统错误）**、**Exception**以及**RuntimeException**拥有cause参数的构造器。如果要把其他类型的异常连接起来，应使用`initCause()`方法而不是构造器。

Throwable对象分为两种类型：`Error`表示编译时和系统错误（一般不用关心）；`Exception`是可以被抛出的基本类型，在Java类库、用户方法以及运行时故障中都可能抛出的Exception型异常。

**运行时异常RuntimeException**会自动被Java虚拟机抛出，都继承自`RuntimeException`类；不需要在异常说明中声明方法将抛出RuntimeException类型的异常，被称为**不受检查异常**。这种异常属于错误，将自动被捕获。如果RuntimeException没有被捕获而直达main()，则将在程序退出前调用异常的printStackTrace()方法。

只能在代码中忽略`RuntimeException`及其子类的异常，其他类型的异常处理都是由编译器强制实施的，根本原因是RuntimeException代表的是编程错误。

**finally字句**

当要把**除内存之外的资源恢复到初始状态时**，就要用到finally字句。如，已经打开的文件或网络连接等。

**异常的限制**

当覆盖方法时，只能抛出在基类方法的异常说明里列出的异常。异常的限制对构造器不起作用。

## 3. 字符串

### 3.1 基本概念

String对象是不可变的，String类中的所有看起来更改String的方法，实际上都创建了一个新的String对象。同一个String对象可以增加任意多的别名，其所有的引用都不可能改变String的值。

StringBuilder是线程**不安全的**，StringBuffer是线程安全的，因此开销较大。

如果再一个类中重写了toString()方法，期望打印该实例的内存地址，则应使用Object.toString()方法，而不能用this。

### 3.2 格式化输出

使用System.out.format()或System.out.printf()格式化输出，与C的printf()类似。java.util.Formatter类，String.format()方法。

## 4. 类型信息

Java在运行时识别对象和类的信息，主要通过两种方式：一种是**传统的RTTI**，假定我们在编译时就知道所有的类型；另一种是**反射**机制，允许我们在运行时发现和使用类的信息。

面向对象的基本目的是，让代码只操纵对基类的引用。这样如果扩展新类，就不会影响到原来的代码。

### 