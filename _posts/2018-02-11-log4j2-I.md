---
layout: post
title: "Log4j2 -- I"
categories: Log4j2
tag: Java-Libs
---
> `Log4j2-v2.10.0-User's Gudie`

## 1.介绍

### 1.1 Log4j2

Log4j 1.x由于需要支持很老的Java版本，在2015年8月停止支持，使用Log4j2的原因如下：

1. Log4j2被设计为可用作审计日志框架。Log4j 1.x和Logback都将在重新配置时丢失事件而Log4j2不会。在Logback中Appenders中的异常对应用程序永远不可见。 在Log4j2中，Appenders可以配置为允许异常渗透到应用程序。

2. Log4j2包含基于LMAX Disruptor库的下一代异步记录器。在多线程场景中，异步记录器比Log4j 1.x和Logback具有10倍的吞吐量和更低的延迟。

3. 在稳态记录期间，Log4j2对于独立应用程序是无垃圾的，对于Web应用程序来说垃圾很少。这减少了垃圾收集器的压力，可以给予更好的响应时间表现。

4. Log4j2使用插件系统，使得通过添加新的Appenders，Filters，Layouts，Lookups和Pattern Converters扩展框架非常容易，而不需要对Log4j的任何更改。

5. 由于插件系统配置比较简单。配置中的条目不需要指定类名称。

6. 支持自定义日志级别。自定义日志级别可以在代码或配置中定义。

7. 支持lambda表达式。在Java8上运行的客户端代码可以使用lambda表达式在只配置请求日志级别的情况下方便的构建日志消息。无需显式级别检查，产生更清洁的代码。

8. 支持Message对象。消息允许支持有趣和复杂的构造器通过日志系统并被有效地操纵。用户可以自由创建他们自己的Message类型并编写自定义Layouts，Filters和Lookups来操纵他们。

9. Log4j 1.x支持Appenders上的Filters。Logback添加了TurboFilters来允许事件在由Logger处理之前实现过滤。Log4j2支持事件在被Logger处理前，通过配置Filter预先处理，就像它们由Logger或Appender处理一样。

10. 许多Logback Appenders不接受Layout，只会以固定格式发送数据。大多数Log4j2 Appenders接受Layout，允许以任何期望的格式传输数据。

11. 在Log4j 1.x和Logback中的Layouts返回一个字符串，这导致了在Logback Encoders中讨论的问题。Log4j2采用更简单的方法，Layouts总是返回一个字节数组。好处就是它可以几乎用于任何Appender，而不仅仅是那些写入OutputStream的。

12. Syslog Appender支持TCP和UDP，同时也支持BSD syslog和RFC5424格式。

13. Log4j2充分利用了利用Java5并发支持，并使死锁的可能降到了最低。Log4j 1.x已知有死锁问题。其中许多已在Logback中解决，但很多Logback类仍然需要相当高的同步要求。

## 2. 架构

### 2.1 架构

#### 2.1.1 主要组件
Log4j2使用的类如下图所示：

![Log4j Main Components](/assets/img/log4j2/20180211_log4j2_maincomp.png)

使用Log4j 2 API的应用程序将向LogManager请求一个具有特定名称的Logger。LogManager将找到相应的LoggerContext，然后从中获取Logger。 如果必须创建Logger，它将与LoggerConfig相关联，此关联的LoggerConfig应包含：与Logger相同的名称，父包的名称，或者root LoggerConfig。LoggerConfig对象是从配置中的Logger声明中创建的。LoggerConfig与实际处理LogEvents的Appender相关联。

**2.1.1.1 Logger Hierarchy**

Logging API相比于纯粹的`System.out.println`最重要的不同是：logging API可以禁用一些log语句输出的同时允许其他一些语句块输出。这种能力建立在开发者按照一定规则将日志分类的基础上。

Log4j1.x的层次关系是通过Loggers之间的关系保持的。而Log4j2无这种关系，是通过LoggerConfig对象来维持这种层次关系的。

Loggers与LoggerConfigs都是带名称的实体。Logger名称是大小写敏感的，并且符合如下命名层级规则：
> 如果一个LoggerConfig的名字是另外一个LoggerConfig名字加上.和一些后缀字符。那么这个LoggerConfig是另外的LoggerConfig的子类。类似于java的 package。

例如：一个名称为"com.foo"的LoggerConfig是一个名称为"com.foo.Bar"的LoggerConfig的父类。类似的，"java"是"java.util"的父类和"java.util.Vector"的祖先类。

RootLoggerConfig驻留在LoggerConfig层次结构的顶部。它永远存在，是每个层级的一部分。直接链接到RootLoggerConfig的记录器可以按如下方式获得：
`Logger logger = LogManager.getLogger(LogManager.ROOT_LOGGER_NAME);`或者，更简单地说：`Logger logger = LogManager.getRootLogger();`可以使用`LogManager.getLogger`静态方法通过传递所需Logger的名称来检索所有其他的Logger。

**2.1.1.2 LoggerContext**

LoggerContext作为日志系统的锚点。然而在不同的环境中，一个应用系统中可能存在多个有效的LoggerContexts。

**2.1.1.3 Configuration**

每个LoggerContext都有一个活动的Configuration。该Configuration包含所有的Appender，上下文范围Filter，LoggerConfig并包含对StrSubstitutor的引用。在重新配置期间，两个配置对象都将存在。一旦所有记录器重定向到新的配置，旧的配置将被停止并丢弃。

**2.1.1.4 Configuration**

Loggers是通过调用`LogManager.getLogger`静态方法创建的。Logger本身不直接执行动作。它只有一个名称，并与一个LoggerConfig相关联。它继承自AbstractLogger并实现了相关的方法。当configuration被修改时，Loggers将关联修改后的LoggerConfig，从而改变这个Loggers 的行为。

使用相同的名称调用LogManager.getLogger方法，总是返回完全相同的Logger 对象。 例如：`Logger x =LogManager.getLogger("wombat"); Logger y =LogManager.getLogger("wombat");`，x和y指向完全相同的Logger对象。Log4j2配置环境通常是在应用程序初始化时完成的。最好的方式是读取配置文件。

Log4j2很容易通过类名来命名。这可以在每个类实例化的时候完成Logger的实例化，此时Logger的名称就等于类的完全限定名，这是一个定义Logger的简单有效的方式。当为日志文件输出具有Logger名称的日志时，这种命名策略可以很容易看出一个日志消息的来源。当然这只是一种比较常见的日志命名方式，log4j2并没有对此进行限制，开发人员可以按照需求进行命名。

因为使用类名命名Logger是一个习惯用法。一个便利的方法是使用`LogManager.getLogger()`来获取类的全路径名称的Logger。目前为止，使用类名来作为Logger 的名称是最好的方式。

**2.1.1.5 LoggerConfig**

当Logger对象在日志Configuration中被定义时，LoggerConfig对象同时被创建。LoggerConfig包含一组Filter来过滤传递到Appenders的LogEvent。LoggerConfig使用一组Appenders的引用用来处理这些事件。

LoggerConfigs将被分配一个日志级别，内建的级别包括：TRACE，DEBUG，INFO，WARN，ERROR，FATAL。Log4j2也支持自定义日志级别，另一种获得更多日志粒度的方式是使用Markers。

Log4j 1.x与Logback都有日志级别继承的概念。在Log4j2中，因为Loggers和LoggerConfigs是2个不同的对象，所以这个概念的实现有所不同。但是因为每个Logger都关联一个相应的LoggerConfig，这个LoggerConfig又可以引用他的父代，从而最终达到相同的效果。

以下的几个表格具有不同的指定级别以及与每个Logger关联的结果级别。请注意，在所有这些情况下，如果未配置RootLoggerConfig，则会为其分配默认级别。

![Log4j LoggerConfig Example1](/assets/img/log4j2/20180211_log4j2_logger_config_example1.png)

在Example 1中只包含了一个Log级别的RootLogger，所有其他的Logger都引用RootLogger及其级别。

![Log4j LoggerConfig Example2](/assets/img/log4j2/20180211_log4j2_logger_config_example2.png)

在Example 2中所有的Logger都有各自的配置LoggerConfig，并从其中获取级别。

![Log4j LoggerConfig Example3](/assets/img/log4j2/20180211_log4j2_logger_config_example3.png)

在Example 3中root，X，X.Y.Z三个Logger分别拥有一个类同名的LoggerConfig。X.Y没有匹配名字的LoggerConfig，所以使用X的LoggerConfig的配置，这是因为此LoggerConfig拥有与X.Y的最长匹配名。

![Log4j LoggerConfig Example4](/assets/img/log4j2/20180211_log4j2_logger_config_example4.png)

在Example 4中root，X两个Logger分别拥有一个类同名的LoggerConfig。X.Y和X.Y.Z没有匹配名字的LoggerConfig，所以使用X的LoggerConfig的配置，这是因为此LoggerConfig拥有与X.Y和X.Y.Z的最长匹配名。

![Log4j LoggerConfig Example5](/assets/img/log4j2/20180211_log4j2_logger_config_example5.png)

在Example 5中root，X，X.Y三个Logger分别拥有一个类同名的LoggerConfig。X.YZ没有匹配名字的LoggerConfig，所以使用X的LoggerConfig的配置，这是因为此LoggerConfig拥有与X.Y的最长匹配名。

![Log4j LoggerConfig Example6](/assets/img/log4j2/20180211_log4j2_logger_config_example6.png)

在Example 6中X.Y的Logger无LoggerConfig而从X继承。X.Y.Z的Logger使用X.Y的LoggerConfig是因为其无名字对应匹配的LoggerConfig，所以继承自X的LoggerConfig。

**2.1.1.6 Filter**

除了前面章节所提到的自动日志级别过滤之外，Log4j2提供了Filter，可以应用于控制权传递到达LoggerConfig之前；以及控制权传递到LoggerConfig之后但在调用Appender之前；控制权在传递到LoggerConfig之后，但是在调用一个指定的 Appender之前。类似于防火墙的处理方式，每个Filters可以返回三个结果的其中之一：`Accept, Deny, Neutral`。Accept意味着不会再调用其他Filters了，LogEvent将被执行；Deny意味着立即忽略这个LogEvent，并将这个LogEvent的控制权交还给它调用者；Neutral指LogEvent将传递给其他Filters，如果没有别的Filter了，那么这个LogEvent将被执行。

尽管一个LogEvent可能被一个Filter接收，但是这个LogEvent可能仍然没有被日志记录下来，发生这种情况的场景可能是LogEvent被pre-LoggerConfig Filter接收了，但是却被LoggerConfig拒绝了，或者被所有的Appender拒绝了。

**2.1.1.7 Appender**

由Logger的不同来决定一个logging request是被禁用还是启用只是log4j2的情景之一。log4j2还允许将logging request中log信息打印到不同的目的地中。在log4j2的世界里，一个输出位置就被称为一个Appender。目前，Appender可以是console、文件、远程socket服务器、Apache Flume、JMS以及远程UNIX
系统日志守护进程，数据库。一个Logger可以绑定多个不同的Appender。

可以通过调用当前Configuration的addLoggerAppender方法为Logger增加一个Appender。如果不存在一个与Logger名称相对应的LoggerConfig，那么相应的LoggerConfig将被创建，并且新增加的Appender将被添加到此新建的LoggerConfig中。然后，所有的Loggers将会被通知更新自己的LoggerConfig引用。

某个Logger中被启用的logging request将被转发到该Logger的LoggerConfig
相关联的的所有Appenders上，并且还会被转发到父级LoggerConfig所关联的Appender上。换句话说，Appender将从LoggerConfig的层次结构中获得继承。例如，如果RootLogger增加了一个console Appender，则所有激活的logging request将至少打印到console中。另外如果一个叫C的LoggerConfig增加了一个file Appender，所有C和C子类中激活的logging request将至少打印到file和console中。如果想避免这种默认的累加效应的话，可以在配置文件中的Logger声明位置做如下设置：`additivity="false"`。

下面是规则的具体解释：

> Logger L的日志将输出到，在LoggerConfig及其父类中与L相关的所有Appender中，这被称为Appender的可加性。然而，如果与Logger L相关的LoggerConfig的祖先（比如P）将可加性标志设置为false，那么L的输出将直接指向L的LoggerConfig中的所有appender，以及直到并包括P在内的所有祖先，但不包括P的所有祖先中的Appender。Appender的可加性默认设置为**true**。

**2.1.1.8 Layout**

通常，用户不止希望能定义日志的输出位置，还希望可以定义输出的格式。这就可以通过将Appender与一个Layout相关联来实现。Log4j2中的一个标准定义PatternLayout，就允许用户使用一种类似C语言printf函数的打印格式，如`%r [%t] %-5p %c - %m%n`格式在真实环境下会打印类似如下的信息：`176 [main] INFO org.foo.Bar - Located nearest gas station.`

第一个字段是启动的毫秒数，第二个字段是日志请求的线程号，第三个字段是日志请求级别，第四个是与日志请求相关联的日志名称，在`-`之后的内容就是日志内容。

Log4j2有各种不同的Layouts，例如：JSON，XML，HTML和Syslog(including the new RFC 5424 version)。其他一些Appender例如database connector会使用指定的字段替代特定的文本布局。

同样重要的是，log4j2会根据用户指定的标准配置日志消息内容。例如：在你的工程中，你需要一个Oranges对象类型的日志，你就可以创建一个OrangeMessage，并接受Orange实例并且传递到log4j2，Orange对象就会被格式化为一个适当的字节数组。

**2.1.1.9 StrSubstitutor and StrLookup**

StrSubstitutor类与StrLookup接口来自Apache Commons Lang，并且被修改为支持LogEvents的运算。此外来自Apache Commons Configuration的Interpolator类允许StrSubstitutor运算来着多个StrLookups的变量，它也被修改支持LogEvents的运算。通过以上修改log4j2提供了一种机制，使得configuration可以引用来自System Properties，configuration，the ThreadContext Map，StructuredData中的变量。如果日志组件可以处理这个变量，则当configuration被加载或每个LogEvent运行时，这个变量将被解析。

## 3. Java API

### 3.1 总览

Log4j2 API提供了应用程序使用的接口，也提供了创建一个日志实现所需的适配器组件。尽管Log4j2解耦了API及其实现之间的关系，但这样做的主要目的是不允许有多个实现。

#### 3.1.1 Hello World

下面是一个HelloWorld的例子，有一个从LogManager中获取的名称为
HelloWorld的Logger，接着，这个Logger打印了`Hello, World!`的日志消息。当然，只有在Logger做了相应的配置，这些内容才能打印出来。

```java
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
public class HelloWorld {
    private static final Logger logger = LogManager.getLogger("HelloWorld");
    public static void main(String[] args) {
        logger.info("Hello, World!");
    }
}
```

调用方法`logger.info()`的输出会有所不同，主要取决于配置。

#### 3.1.2 Substituting Parameters

通常日志的目的是提供系统中发生的信息，这就要打印一些对象信息，在Log4j 1.x中，可以通过这样来打印：

```java
if (logger.isDebugEnabled()) {
    logger.debug("Logging in user " + user.getName() + " with birthday " + user.getBirthdayCalendar());
}
```

这样的代码感觉很繁琐，而且会检查2次日志级别，一次是`logger.isDebugEnabled()`，另一次是`logger.debug()`。在log4j2中更好的实现方式是：

```java
logger.debug("Logging in user {} with birthday {}", user.getName(), user.getBirthdayCalendar());
```

代码简洁了很多， 而且日志只有在debug打印的时候才会构建日志内容中的字符串。

#### 3.1.3 Formatting Parameters

如果`toString()`不能满足日志需要，Formatter Logger提供了格式化方式，使用与Java中Formatter相同的格式化字符串，如：

```java
public static Logger logger = LogManager.getFormatterLogger("Foo");
logger.debug("Logging in user %s with birthday %s", user.getName(), user.getBirthdayCalendar());
logger.debug("Logging in user %1$s with birthday %2$tm %2$te,%2$tY", user.getName(), user.getBirthdayCalendar());
logger.debug("Integer.MAX_VALUE = %,d", Integer.MAX_VALUE);
logger.debug("Long.MAX_VALUE = %,d", Long.MAX_VALUE);
```

使用格式化Logger，必须使用LogManager的`getFormatterLogger`方法，例子结果如下：

```
2012-12-12 11:56:19,633 [main] DEBUG: User John Smith with birthday java.util.GregorianCalendar[time=?,areFieldsSet=
2012-12-12 11:56:19,643 [main] DEBUG: User John Smith with birthday 05 23, 1995
2012-12-12 11:56:19,643 [main] DEBUG: Integer.MAX_VALUE = 2,147,483,647
2012-12-12 11:56:19,643 [main] DEBUG: Long.MAX_VALUE = 9,223,372,036,854,775,807
```

#### 3.1.4 Mixing Loggers with Formatter Loggers

Formatter loggers是用来控制细粒度的输出格式的，但是缺点是必须指定正确的类型，例如给%d格式化参数传递了Integer以外的类型，就会抛错。

如果你主要使用`{}`风格的参数，但是偶尔要精确控制输出格式，可以使用printf方法：

```java
public static Logger logger = LogManager.getLogger("Foo");
logger.debug("Opening connection to {}...", someDataSource);
logger.printf(Level.INFO, "Logging in user %1$s with birthday %2$tm %2$te,%2$tY", user.getName(), user.getBirthdayCalendar());
```

#### 3.1.5 Java 8 lambda support for lazy logging

#### 3.1.6 Logger Names

大部分日志实现使用为了使得日志名称与日志配置匹配使用一个分层的名称方案。在这个方案中Logger的名称是由`.`分隔的，非常类似于java包名的层次。例如：
org.apache.logging是org.apache.logging.appender与org.apache.logging.filter的父层。大多数情况下，应用命名他们的Logger是通过在`LogManager.getLogger()`中传入当前类名实现的。因为这个用法太常见，Log4j2在传入参为空或者传入为Null的时候默认是提供当前类的名称。例如，下面的例子的 Logger的名称都是org.apache.test.MyTest。

```java
package org.apache.test;
public class MyTest {
private static final Logger logger = LogManager.getLogger(MyTest.class);
}

package org.apache.test;
public class MyTest {
private static final Logger logger = LogManager.getLogger(MyTest.class.getName());
}

package org.apache.test;
public class MyTest {
private static final Logger logger = LogManager.getLogger();
}
```

### 3.2 Flow Tracing

Logger类提供了对于跟踪应用程序执行路径非常有用的日志记录方法。这些方法生成可以从其他调试日志记录中单独过滤的日志记录事件。鼓励自由使用这些方法，这是因为输出是为了：

- 无需调试会话即可帮助开发中的问题诊断
- 在没有调试可能的情况下帮助生产中的问题诊断
- 帮助教育新开发人员学习应用程序。

最常用的方法是entry()、traceEntry()和exit()、traceExit()方法。entry()或traceEntry()应该放在方法的开头，除了简单的getter和setter。entry()可以在调用时传递0到4个参数，通常这些将是传递给该方法的参数。traceEntry()可以传递一个格式化String和一个变量列表的参数，或一个Message。entry()和traceEntry()方法使用TRACE级别进行记录，并使用名称为“ENTER”的Marker，该标记也是“FLOW”Marker，所有消息字符串将以“event”开头，即使使用格式化String或使用Message。

entry()和traceEntry()方法之间的主要区别在于entry方法接受一个可变的对象列表，其中每个对象都是一个方法参数。traceEntry方法接受一个格式字符串，后跟一个可变的对象列表，可能包含在String格式中。但是不可能有一个单一的方法包含这两种方式，因为这会导致无法判断第一个字符串是参数还是格式字符串。

exit()或traceExit()方法应放在任何return语句之前，或作为方法的最后一个语句而不返回。可以使用或不使用参数调用exit()和traceExit()。通常，返回void的方法将使用exit()或traceExit()，而返回Object的方法将使用exit(Object obj)或traceExit(object，new SomeMessage(object))。 exit()和traceExit()方法使用TRACE级别进行记录，并使用名称为“EXIT”的Marker，该标记也是“FLOW”Marker，所有消息字符串将以“exit”开头，即使使用格式化String或使用Message。

应用程序在抛出一个不太可能被处理的异常（如RuntimeException）时可以使用throwing()方法。这将确保如果需要可以进行正确的诊断。生成的记录事件将具有ERROR级别，并且将关联名为“THROWING”的Marker，该标记也是“EXCEPTION”标记。

当捕获的是一个不会显式地重新抛出或可以附加到另一个异常的Exception时，应用程序可使用catching()方法。生成的记录事件将具有ERROR级别，并且将关联名为“CATCHING”的Marker，该标记也是“EXCEPTION”标记。

以下示例典型的展示了使用这些方法的简单应用。当没有Exception被显式的抛出和处理时，throwing()不存在。

```java
package com.test;

import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;
import java.util.Random;

public class TestService {
    private Logger logger = LogManager.getLogger(TestService.class.getName());

    private String[] messages = new String[] {
        "Hello, World",
        "Goodbye Cruel World",
        "You had me at hello"
    };
    private Random rand = new Random(1);

    public void setMessages(String[] messages) {
        logger.traceEntry(new JsonMessage(messages));
        this.messages = messages;
        logger.traceExit();
    }

    public String[] getMessages() {
        logger.traceEntry();
        return logger.traceExit(messages, new JsonMessage(messages));
    }

    public String retrieveMessage() {
        logger.entry();
        String testMsg = getMessage(getKey());
        return logger.exit(testMsg);
    }

    public void exampleException() {
        logger.entry();
        try {
            String msg = messages[messages.length];
            logger.error("An exception should have been thrown");
        } catch (Exception ex) {
            logger.catching(ex);
        }
        logger.exit();
    }

    public String getMessage(int key) {
        logger.entry(key);
        String value = messages[key];
        return logger.exit(value);
    }

    private int getKey() {
        logger.entry();
        int key = rand.nextInt(messages.length);
        return logger.exit(key);
    }
}
```