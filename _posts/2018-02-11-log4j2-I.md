---
layout: post
title: "Log4j2 -- I"
categories: Log4j2
tag: Java-Libs
---
> `Log4j2-v2.10.0-User's Gudie`

## 1.介绍

### 1.1 Log4j2

Log4j 1.x由于需要支持很老的Java版本，在2015年8月停止支持，使用Log4j2的原因如下：

1. Log4j2被设计为可用作审计日志框架。Log4j 1.x和Logback都将在重新配置时丢失事件而Log4j2不会。在Logback中Appenders中的异常对应用程序永远不可见。 在Log4j2中，Appenders可以配置为允许异常渗透到应用程序。

2. Log4j2包含基于LMAX Disruptor库的下一代异步记录器。在多线程场景中，异步记录器比Log4j 1.x和Logback具有10倍的吞吐量和更低的延迟。

3. 在稳态记录期间，Log4j2对于独立应用程序是无垃圾的，对于Web应用程序来说垃圾很少。这减少了垃圾收集器的压力，可以给予更好的响应时间表现。

4. Log4j2使用插件系统，使得通过添加新的Appenders，Filters，Layouts，Lookups和Pattern Converters扩展框架非常容易，而不需要对Log4j的任何更改。

5. 由于插件系统配置比较简单。配置中的条目不需要指定类名称。

6. 支持自定义日志级别。自定义日志级别可以在代码或配置中定义。

7. 支持lambda表达式。在Java8上运行的客户端代码可以使用lambda表达式在只配置请求日志级别的情况下方便的构建日志消息。无需显式级别检查，产生更清洁的代码。

8. 支持Message对象。消息允许支持有趣和复杂的构造器通过日志系统并被有效地操纵。用户可以自由创建他们自己的Message类型并编写自定义Layouts，Filters和Lookups来操纵他们。

9. Log4j 1.x支持Appenders上的Filters。Logback添加了TurboFilters来允许事件在由Logger处理之前实现过滤。Log4j2支持事件在被Logger处理前，通过配置Filter预先处理，就像它们由Logger或Appender处理一样。

10. 许多Logback Appenders不接受Layout，只会以固定格式发送数据。大多数Log4j2 Appenders接受Layout，允许以任何期望的格式传输数据。

11. 在Log4j 1.x和Logback中的Layouts返回一个字符串，这导致了在Logback Encoders中讨论的问题。Log4j2采用更简单的方法，Layouts总是返回一个字节数组。好处就是它可以几乎用于任何Appender，而不仅仅是那些写入OutputStream的。

12. Syslog Appender支持TCP和UDP，同时也支持BSD syslog和RFC5424格式。

13. Log4j2充分利用了利用Java5并发支持，并使死锁的可能降到了最低。Log4j 1.x已知有死锁问题。其中许多已在Logback中解决，但很多Logback类仍然需要相当高的同步要求。

## 2. 架构

### 2.1 架构

#### 2.1.1 主要组件
Log4j2使用的类如下图所示：
![Log4j Main Components](/assets/img/log4j2/20180211_log4j2_maincomp.png)
使用Log4j 2 API的应用程序将向LogManager请求一个具有特定名称的Logger。LogManager将找到相应的LoggerContext，然后从中获取Logger。 如果必须创建Logger，它将与LoggerConfig相关联，此关联的LoggerConfig应包含：与Logger相同的名称，父包的名称，或者root LoggerConfig。LoggerConfig对象是从配置中的Logger声明中创建的。LoggerConfig与实际处理LogEvents的Appender相关联。

**2.1.1.1 Logger Hierarchy**

Logging API相比于纯粹的`System.out.println`最重要的不同是：logging API可以禁用一些log语句输出的同时允许其他一些语句块输出。这种能力建立在开发者按照一定规则将日志分类的基础上。

Log4j1.x的层次关系是通过Loggers之间的关系保持的。而Log4j2无这种关系，是通过LoggerConfig对象来维持这种层次关系的。

Loggers与LoggerConfigs都是带名称的实体。Logger名称是大小写敏感的，并且符合如下命名层级规则：
> 如果一个LoggerConfig的名字是另外一个LoggerConfig名字加上.和一些后缀字符。那么这个LoggerConfig是另外的LoggerConfig的子类。类似于java的 package。

例如：一个名称为"com.foo"的LoggerConfig是一个名称为"com.foo.Bar"的LoggerConfig的父类。类似的，"java"是"java.util"的父类和"java.util.Vector"的祖先类。

RootLoggerConfig驻留在LoggerConfig层次结构的顶部。它永远存在，是每个层级的一部分。直接链接到RootLoggerConfig的记录器可以按如下方式获得：
`Logger logger = LogManager.getLogger(LogManager.ROOT_LOGGER_NAME);`或者，更简单地说：`Logger logger = LogManager.getRootLogger();`可以使用`LogManager.getLogger`静态方法通过传递所需Logger的名称来检索所有其他的Logger。

**2.1.1.2 LoggerContext**

LoggerContext作为日志系统的锚点。然而在不同的环境中，一个应用系统中可能存在多个有效的LoggerContexts。

**2.1.1.3 Configuration**

每个LoggerContext都有一个活动的Configuration。该Configuration包含所有的Appender，上下文范围Filter，LoggerConfig并包含对StrSubstitutor的引用。在重新配置期间，两个配置对象都将存在。一旦所有记录器重定向到新的配置，旧的配置将被停止并丢弃。

**2.1.1.4 Configuration**

Loggers是通过调用`LogManager.getLogger`静态方法创建的。Logger本身不直接执行动作。它只有一个名称，并与一个LoggerConfig相关联。它继承自AbstractLogger并实现了相关的方法。当configuration被修改时，Loggers将关联修改后的LoggerConfig，从而改变这个Loggers 的行为。

使用相同的名称调用LogManager.getLogger方法，总是返回完全相同的Logger 对象。 例如：`Logger x =LogManager.getLogger("wombat"); Logger y =LogManager.getLogger("wombat");`，x和y指向完全相同的Logger对象。Log4j2配置环境通常是在应用程序初始化时完成的。最好的方式是读取配置文件。

Log4j2很容易通过类名来命名。这可以在每个类实例化的时候完成Logger的实例化，此时Logger的名称就等于类的完全限定名，这是一个定义Logger的简单有效的方式。当为日志文件输出具有Logger名称的日志时，这种命名策略可以很容易看出一个日志消息的来源。当然这只是一种比较常见的日志命名方式，log4j2并没有对此进行限制，开发人员可以按照需求进行命名。

因为使用类名命名Logger是一个习惯用法。一个便利的方法是使用`LogManager.getLogger()`来获取类的全路径名称的Logger。目前为止，使用类名来作为Logger 的名称是最好的方式。

**2.1.1.5 LoggerConfig**

当Logger对象在日志Configuration中被定义时，LoggerConfig对象同时被创建。LoggerConfig包含一组Filter来过滤传递到Appenders的LogEvent。LoggerConfig使用一组Appenders的引用用来处理这些事件。

LoggerConfigs将被分配一个日志级别，内建的级别包括：TRACE，DEBUG，INFO，WARN，ERROR，FATAL。Log4j2也支持自定义日志级别，另一种获得更多日志粒度的方式是使用Markers。

Log4j 1.x与Logback都有日志级别继承的概念。在Log4j2中，因为Loggers和LoggerConfigs是2个不同的对象，所以这个概念的实现有所不同。但是因为每个Logger都关联一个相应的LoggerConfig，这个LoggerConfig又可以引用他的父代，从而最终达到相同的效果。

以下的几个表格具有不同的指定级别以及与每个Logger关联的结果级别。请注意，在所有这些情况下，如果未配置RootLoggerConfig，则会为其分配默认级别。

![Log4j LoggerConfig Example1](/assets/img/log4j2/20180211_log4j2_logger_config_example1.png)

在Example 1中只包含了一个Log级别的RootLogger，所有其他的Logger都引用RootLogger及其级别。

![Log4j LoggerConfig Example2](/assets/img/log4j2/20180211_log4j2_logger_config_example2.png)

在Example 2中所有的Logger都有各自的配置LoggerConfig，并从其中获取级别。

![Log4j LoggerConfig Example3](/assets/img/log4j2/20180211_log4j2_logger_config_example3.png)

在Example 3中root，X，X.Y.Z三个Logger分别拥有一个类同名的LoggerConfig。X.Y没有匹配名字的LoggerConfig，所以使用X的LoggerConfig的配置，这是因为此LoggerConfig拥有与X.Y的最长匹配名。

![Log4j LoggerConfig Example4](/assets/img/log4j2/20180211_log4j2_logger_config_example4.png)

在Example 4中root，X两个Logger分别拥有一个类同名的LoggerConfig。X.Y和X.Y.Z没有匹配名字的LoggerConfig，所以使用X的LoggerConfig的配置，这是因为此LoggerConfig拥有与X.Y和X.Y.Z的最长匹配名。

![Log4j LoggerConfig Example5](/assets/img/log4j2/20180211_log4j2_logger_config_example5.png)

在Example 5中root，X，X.Y三个Logger分别拥有一个类同名的LoggerConfig。X.YZ没有匹配名字的LoggerConfig，所以使用X的LoggerConfig的配置，这是因为此LoggerConfig拥有与X.Y的最长匹配名。

![Log4j LoggerConfig Example6](/assets/img/log4j2/20180211_log4j2_logger_config_example6.png)

在Example 6中X.Y的Logger无LoggerConfig而从X继承。X.Y.Z的Logger使用X.Y的LoggerConfig是因为其无名字对应匹配的LoggerConfig，所以继承自X的LoggerConfig。

**2.1.1.6 Filter**

除了前面章节所提到的自动日志级别过滤之外，Log4j2提供了Filter，可以应用于控制权传递到达LoggerConfig之前；以及控制权传递到LoggerConfig之后但在调用Appender之前；控制权在传递到LoggerConfig之后，但是在调用一个指定的 Appender之前。类似于防火墙的处理方式，每个Filters可以返回三个结果的其中之一：`Accept, Deny, Neutral`。Accept意味着不会再调用其他Filters了，LogEvent将被执行；Deny意味着立即忽略这个LogEvent，并将这个LogEvent的控制权交还给它调用者；Neutral指LogEvent将传递给其他Filters，如果没有别的Filter了，那么这个LogEvent将被执行。

尽管一个LogEvent可能被一个Filter接收，但是这个LogEvent可能仍然没有被日志记录下来，发生这种情况的场景可能是LogEvent被pre-LoggerConfig Filter接收了，但是却被LoggerConfig拒绝了，或者被所有的Appender拒绝了。

**2.1.1.7 Appender**

由logger的不同来决定一个logging request是被禁用还是启用只是log4j2的情景之一。log4j2还允许将logging request中log信息打印到不同的目的地中。在log4j2的世界里，一个输出位置就被称为一个Appender。目前，Appender可以是console、文件、远程socket服务器、Apache Flume、JMS以及远程UNIX
系统日志守护进程，数据库。一个Logger可以绑定多个不同的Appender。

可以通过调用当前Configuration的addLoggerAppender方法为Logger增加一个Appender。如果不存在一个与Logger名称相对应的LoggerConfig，那么相应的LoggerConfig将被创建，并且新增加的Appender将被添加到此新建的LoggerConfig中。然后，所有的Loggers将会被通知更新自己的LoggerConfig引用。

某个logger中被启用的logging request将被转发到该Logger的LoggerConfig
相关联的的所有Appenders上，并且还会被转发到父级LoggerConfig所关联的Appender上。换句话说，Appender将从LoggerConfig的层次结构中获得继承。例如，如果RootLogger增加了一个console Appender，则所有激活的logging request将至少打印到console中。另外如果一个叫C的LoggerConfig增加了一个file Appender，所有C和C子类中激活的logging request将至少打印到file和console中。如果想避免这种默认的累加效应的话，可以在配置文件中的Logger声明位置做如下设置：`additivity="false"`。