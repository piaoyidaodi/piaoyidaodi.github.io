---
layout: post
title: "Java编程思想--关键概念I"
categories: Thinking-In-Java-Note
tag: Core-Java
---
> `java`中一些重要的概念，**方法重载、清理、初始化、组合和继承、多态**。

### 1. 方法重载

1. 生活中，相同的词可以表达多种不同的含义——他们被**重载**了。**方法重载**解决了相同方法名相同概念的方法的命名问题。
- 构造器是一种特殊类型的方法，因为它没有返回值，且与返回值为`void`方法明显不同。
- 为了让方法名相同而形式参数不同的构造器同时存在，因此必须用到**方法重载**。

2. 区分重载的规则：每个重载的方法都必须有一个**独一无二的参数类型列表**。

3. 基本类型作为参数重载：传入数据类型小于方法中声明的形参类型，实际数据类型会提升，`char`直接提升为`int`。

### 2. 清理：终结处理和垃圾回收

1. `finalize()`并非`C++`中的析构函数。在`Java`中：对象可能不被垃圾回收；垃圾回收并不等于“析构”；垃圾回收只与内存有关。

2. `finalize()`主要使用在**本地方法**情况。

### 3. 初始化

#### 3.1 成员初始化

`Java`尽力保证：所有的变量在使用前都能得到恰当的初始化。对于方法的局部变量，以编译错误的形式来贯彻。

#### 3.2 构造器初始化

1. **无法阻止自动初始化的进行**，它将在构造器被调用之前发生。

2. 在类的内部，**变量定义的先后顺序**决定了初始化顺序。即使变量定义散布于方法定义之间，它们仍旧会在**任何方法（包括构造器）被调用之前得到初始化**。

3. 无论创建多少个对象，静态数据都只占用**一份存储区域**。`static`关键字不能应用于局部变量，因此只能作用于域。如果一个域是静态的基本类型域，且没有对它进行初始化，那么它就会获得基本类型的标准初值；如果是一个对象引用，默认初始化值为`null`。

#### 3.3 数组初始化

1. 数组只是相同类型的、用一个标识符名称封装到一起的一个对象序列或基本类型数据序列。

2. 编译器不允许指定数组的大小；对于数组，初始化动作可以在代码的任何地方，但是对于**初始化表达式出现在创建数组的地方**，存储空间的分配等价于使用`new`，即编译器负责。

3. 基本类型数组可以使用`new`（不能使用`new`创建单个基本类型数组）；如果创建了一个非基本类型的数组，就创建了一个引用数组。

#### 3.4 引用的初始化

引用初始化的位置：

- 在定义的地方，可以确保在构造器被调用之前引用被初始化。
- 在类的构造器中。
- 在正要使用这些对象之前，称为**惰性初始化**。
- 使用实例初始化。

#### 3.5 对象创建过程（假设有一个`Dog`类继承于`Animal`类）：

1. 首次创建类型为`Dog`的对象时（构造器可以看做`static`方法），或者`Dog`类的静态方法/静态域首次被访问时，`Java`解释器必须查找类路径，以定位`Dog.class`文件。

2. 然后载入`Dog.class`，有关静态初始化的所有动作都会执行。**静态初始化只在Class对象首次加载时进行一次**。

3. 当用`new Dog()`创建对象时，首先将在堆上为`Dog`对象分配足够的存储空间。

4. **存储空间会被清零**，此时`Dog`对象内所有的**基本类型设为默认值，引用则被设置成了`null`**。

5. 此时依据1-4步，执行`Animal`父类的初始化

6. **按照声明的顺序执行所有出现于字段定义处的初始化动作**。

7. 执行`Animal`的构造器。

8. 依据6-7步，执行`Dog`对象的构造器。

#### 3.6 举个初始化的例子：

  ```java
public class Test extends Base {
    static int flag=5;
    static {
        System.out.println("flag is :::"+flag);
    }
    int r=10;
    Test(){
        System.out.println("Test init...");
        System.out.println("init the "+(flag++)+" time");
        echo();
        System.out.println("Test finish init...");
        System.out.println();
    }

    public void echo(){
        System.out.println("---Test Echo---");
        System.out.println("Test r is : "+r);
    }

    public static void main(String[] args){
        new Test();
    }
}
class Base{
    static int r=5;
    static int baseFlag=1;
    int i1=100;
    static {
        System.out.println("r is :::"+r);
        System.out.println("--分割线1--");
    }
    static Test test=new Test();
    static int i2=5;
    static {
        System.out.println("--分割线2--");
    }
    Base(){
        System.out.println("Base init...");
        System.out.println("init the "+(baseFlag++)+" time");
        System.out.println("the static i is "+ i2);
        System.out.println("the dynamic i is "+ i1);
        echo();
        System.out.println("Base finish init...");
        System.out.println();
    }
    public void echo(){
        System.out.println("---Base Echo---");
        System.out.println("Base r is : "+r);
    }
}
  ```

  > 结果如下：

    1.    r is :::5
    2.    --分割线1--
    3.    Base init...
    4.    init the 1 time
    5.    the static i is 0
    6.    the dynamic i is 100
    7.    ---Test Echo---
    8.    Test r is : 0
    9.    Base finish init...
    10.
    11.   Test init...
    12.   init the 0 time
    13.   ---Test Echo---
    14.   Test r is : 10
    15.   Test finish init...
    16.
    17.   --分割线2--
    18.   flag is :::5
    19.   Base init...
    20.   init the 2 time
    21.   the static i is 5
    22.   the dynamic i is 100
    23.   ---Test Echo---
    24.   Test r is : 0
    25.   Base finish init...
    26.
    27.   Test init...
    28.   init the 5 time
    29.   ---Test Echo---
    30.   Test r is : 10
    31.   Test finish init...

解释如下，运行环境`Java 1.8`：

1. `main()`中首次执行`new Test()`，虚拟机查找`Test`类路径并确定`Test`类，为`Test`类**静态字段**分配空间，同时完成自动初始化（内存置零）。
2. 此时发现`Test`继承了`Base`，虚拟机查找`Base`类路径并确定`Base`类，为`Base`类**静态字段**分配空间，同时完成自动初始化（内存置零）。

3. 按照**静态域**的声明顺序初始化，即`r = 5 , baseFlag = 1`，**`i2`**此时仍未初始化值为**`0`**，输出第1-2行。

4. 此时`Base()`中声明**静态对象`new Test()`**，由于`Test`和`Base`类已经加载，此时的`new Test()`产生的对象**认为`Test`和`Base`的静态域已完成加载和初始化（其实并没有完成初始化，只是完成了自动初始化）**。

5. 因此先为`Test`的**非静态字段**分配空间，同时完成自动初始化（内存置零），再为`Base`类**非静态字段**分配空间，同时完成自动初始化（内存置零）。

6. 然后为`Base`中的**非静态字段**完成初始化，即`i1 = 100`。

7. 接着执行`Base`的构造器初始化，输出第3-6行；此时遇到`echo()`函数，由于**多态**调用了`Test`类中的`echo()`函数，此时`Test`对象的非静态域**只完成了自动初始化**即`r = 0`，输出7-8行后返回`Base`中执行打印出9-10行，完成`Base`的构造器初始化。

8. 接着执行`Test`中的**非静态字段**完成初始化，即`r = 10`；后执行`Test`的构造器初始化，输出第11-16行。**静态Test对象**完成初始化。注意其中`flag`只完成了自动初始化，所以为`0`。

9. 此时，继续`Base()`中声明**静态Test对象**的初始化，接着`i2`被初始化即`i2 = 5`，打出17行。**`Base`的静态域完成初始化`**。

10. **接着执行`Test`的静态域初始化**，即`flag = 5`，打印出第18行。

11. **此时`Test`和`Base`的静态域初始化已完全结束**。

12. 执行`Test`和`Base`的**非静态域初始化**，即第5-6步；接着执行`Base`的构造器初始化，输出第19-22行；此时遇到`echo()`函数，由于**多态**调用了`Test`类中的`echo()`函数，此时`Test`对象的非静态域**只完成了自动初始化**即`r = 0`，输出23-24行后返回`Base`中执行打印出25-26行，完成`Base`的构造器初始化。

13. 接着执行`Test`中的**非静态字段**完成初始化，即`r = 10`；后执行`Test`的构造器初始化，输出第27-31行。**`main()`中的Test对象**完成初始化。

14. 所有代码运行完毕，并返回。

### 4. 组合和继承

#### 4.1 初始化基类

1. 继承并不只是赋值父类的接口。

2. 当创建一个子类对象时，该对象**包含了一个父类对象**。

3. 这个对象与使用父类创建的对象时一样的。**区别在于：**后者来自于外部，父类对象被包装在子类对象内部。

4. `Java`会**自动在子类的构造器中插入对父类构造器的调用**。如果使用带参数的构造器，必须使用`super`显式的调用父类构造器。

#### 4.2 代理

1. 代理：**继承和组合**的中庸之道，因为将一个成员对象置于所要构造的类中（就像组合），但同时在新类中暴露了该成员对象的所有方法（就像继承）。

#### 4.3 名称屏蔽

1. 在`Java`的父类中的某个多次重载的方法，在子类中重新定义该方法名称不会屏蔽父类中的任何版本。

2. 使用`@Override`注解时，当不小心重载而非覆写某个方法时，编译器会报错。

#### 4.4 组合与继承的选择

1. 组合技术通常用于**想在新类中使用现有类的功能而非它的接口这类情形**，即，在新类中嵌入某个对象，让其实现所需要的功能。

#### 4.5 向上转型

1. 为新类提供方法并**不是**继承的主要方面，其最重要的方面是用来**表现新类和基类之间的关系**。

2. 在面向对象编程中，生成和使用程序代码最有可能采用的方法就是直接将数据和方法包装进一个类中，并使用该类的对象。可运用组合使用现有类开发新的类，而继承其实不太常用。

3. 到底使用组合还是继承，最清晰的办法是判断**是否需要从子类向父类进行向上转型**。

### 5. 多态

#### 5.1 玄学思想

1. 多态通过分离做什么和怎么做，从另一个角度将接口和实现分离开。多态的作用是**消除类型之间的耦合**，通过**动态绑定**实现。

2. **封装**通过合并特征和行为来创建新的数据类型；**实现隐藏**则将细节私有化把接口和实现分离开。

#### 5.2 绑定

1. 将一个方法调用同一个方法主体关联起来被称为**绑定**，若程序在执行前进行绑定，叫做前期绑定。

2. 在运行时根据对象类型进行绑定称为**后期绑定**或**动态绑定、运行时绑定**。

3. `Java`中除了`static`和`final`方法（`private`方法属于`final`方法），其他所有的方法都是**动态绑定**的。

#### 5.3 缺陷

1. 覆盖`private`方法
- 只有**非`private`**方法才可以被覆盖。
- 若覆盖`private`方法，编译器虽然不会报错，但也不会按照期望来执行。所以在子类中采用与父类`private`方法不同的名字。

2. 域与静态方法
- **只有普通的方法可以是多态的**。

#### 5.4 构造器和多态

1. **构造器不具有多态性**，构造器的特殊任务：**用来检查对象是否被正确的构造**。

2. 构造器的调用，原因：
- 父类构造器总是在子类的构造过程中被调用，而且**按照继承层次逐渐向上链接，以使所有父类构造器都能得到调用**。
- 只有父类构造器才有恰当的知识和权限对自己的成员进行初始化。
- 必须令所有构造器都能得到调用，否则就不可能正确构造完整对象，因此强制每个子类都必须调用构造器。
- 子类构造器中没有明确指定父类构造器时，会调用**默认构造器**，若不存在则编译器报错。

3. 实例构造调用顺序：
- 调用基类构造器；
- 按照声明顺序调用成员的初始化方法；
- 调用子类构造器的主体。

4. 继承与清理
- 首先对子类进行清理，然后才是父类。这是因为子类中的清理可能会使用父类中的某些方法。

5. 构造器内唯一能够安全调用的是基类中的`final`方法。

#### 5.5 用继承进行设计

1. 首选使用**组合**，组合不会强制程序设计进入继承的层次结构中，且可以动态选择类型更加灵活。

2. 用继承表达行为间的差异，并用字段表达状态上的变化。