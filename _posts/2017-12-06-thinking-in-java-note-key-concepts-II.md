---
layout: post
title: "Java编程思想--关键概念II"
categories: Thinking-In-Java-Note
tag: Core-Java
---
> `java`中一些重要的概念，**接口、内部类**等。

### 1. 接口

#### 1.1  玄学思想

1. 尽管在构建具有某些未实现方法的类时，第一想法可能是创建接口，但是抽象类仍旧是用于此目的的一种重要且必须的工具。因为你不可能总是使用纯接口。

#### 1.2 抽象类和抽象方法

1. **抽象方法**不完整，但仅有声明而没有方法体。`abstract void f();`。

2. 如果有一个类，我们想阻止产生这个类的任何对象，可以创建一个**没有任何抽象方法的抽象类**。

3. 恰当的原则是**优先选择类而不是接口**。从类开始，如果接口的必须性变得非常明确，那么就进行重构。

#### 1.3 接口

1. `abstract`关键字允许人们在类中创建**一个或多个**没有任何定义的方法。`interface`产生一个完全抽象的类，没有任何具体的实现。

2. 所有实现了特定接口的类看起来都像这样。接口被用来建立类与类之间的协议。接口可包含域，但是这些域隐式的为`static`和`final`。

3. 只要一个方法操作的是类而非接口，那么就只能使用这个类及其子类。

4. 策略设计模式，是接口的常见用法。不同的策略使用相同的策略接口。

5. 接口是实现多重继承的途径，而**生成遵循某个接口的对象**的典型方法就是**工厂方法设计模式**。

#### 1.4 多重继承

1. 组合多个类的接口的行为成为**多重继承**。`Java`只能继承自一个非接口的类，并组合多个接口，并且都可以向上转型为任意接口。

2. 使用接口的原因：
- 为了能向上转型为多个基类型。
- 与抽象类一样，防止客户端程序员创建该类的对象。
- 如果知道某事物应该成为一个基类，那么第一选择是将其设计为接口。

3. 接口是可以互相继承，以扩展新的接口。应尽量避免组合接口中具有相同的方法名。

#### 1.5 接口中的域

1. 接口可包含域，但是这些域隐式的位`static`和`final`。所以接口成了一种**便捷创建常量组**的工具。

2. 接口中定义的域不能是**空白`final`**，但是可以被**非常量表达式**初始化。

### 2. 内部类

#### 2.1  玄学思想

1. 将一个类的定义放在另一个类的内部，就是内部类。

2. 内部类除了可以实现代码隐藏（将类置于其他类的内部），它还了解外围类，并能与之通信。

#### 2.2 内部类的创建和链接

1. 如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，必须具体的指明对象的类型：`OuterClassName.InnerClassName`。

2. 当生成一个内部类的对象时，此对象与制造它的外部对象之间就有了联系，可以访问其外围对象的所有成员，而不需要任何特殊条件。此外内部类还拥有外围类所有元素的访问权。

3. 当内部类是**非`static`类**时（即非**嵌套类**），内部类对象只能在与其外围类对象相关联的情况下，才能被创建。构建内部类对象时，需要一个指向其外围类对象的引用。在拥有外围类对象之前是不可能创建内部类对象的。

4. 如果需要生成对外部类对象的引用，可以使用外部类的名字后紧跟`.this`。通过外部类对象创建内部类对象使用`OuterClass.new InnerClass()`。

5. `private/protected InnerClass{}`，访问权限修饰符作用在内部类前的意义，与其他字段方法所代表的访问权限一致。

6. **`private`内部类**提供了一种途径，通过这种方式可以完全阻止任何依赖于类型的编码，并且完全隐藏了实现细节。`private`内部类实现接口，通过外部类方法获取内部类对象。

7. 在外部类方法作用域内定义的内部类，成为局部内部类。
- 局部内部类**是方法的一部分**，而**不是外部类的一部分**，所以在方法之外不能访问内部类。
- 虽然在方法内定义内部类，但并不意味着方法执行结束后，内部类就不可用了。

#### 2.3 匿名内部类

1. 将返回值的**生成**与表示这个返回值的**类定义**结合在一起。

2. 匿名内部类使用有参数构造器，只需要简单传递合适的参数给基类的构造器即可；如果匿名内部类使用外部定义的对象，那么编译器会要求其参数引用为`final`的。

3. 对于匿名内部类而言，实例初始化的实际效果就是构造器，受到了限制--不能重载实例初始化方法。

#### 2.4 嵌套类

1. 如果不需要内部类对象与其外围类对象之间有联系，将内部类声明为`static`，称为嵌套类。`static`内部类，无外围类对象的引用，因此：
- 创建嵌套类的对象，不需要其外围类的对象；
- 不能从嵌套类的对象中访问非静态的外围类对象。
- 普通内部类不能有static数据和static字段，也不能包含嵌套类。但是嵌套类可以。

2. 正常情况下，不能在接口内部放置任何代码，但嵌套类可以作为接口的一部分。放到接口中的任何类都自动的是public和static的。因为类是static的，只是将嵌套类置于接口的命名空间内，这并不违反接口的规则。甚至可以在内部类中实现外围接口。

3. 为什么使用内部类？一般来说，内部类继承自某个类或实现某个接口，内部类的代码操作创建它的外围类的对象，所以可以认为内部类提供了某种进入其外围类的窗口。

4. 使用内部类实现一个接口与外围类实现这个接口有什么区别？外围类实现不是总能享受到接口带来的方便，而每个内部类都能独立的继承自一个接口的实现，所以无论外围类是否已经继承了某个接口的实现，对内部类都没有影响。

5. **内部类由于允许继承多个非接口类型的类或抽象类，而有效的实现了多重继承**

6. 内部类的其他特性：
- 内部类可以有多个实例，每个实例都有自己的状态信息，并且与外围类对象的信息相互独立。
- 在单个外围类中，可以让多个内部类以不同的方式实现一个接口，或继承统一个类。
- 创建内部类对象的时刻并不依赖于外围类对象的创建。
- 内部类并没有令人迷惑的is-a关系，它就是一个独立的实体。

7. 当继承了某个外围类时，内部类并没有发生什么变化，他们在各自独立的两个实体，各自在自己的命名空间内。

8. 局部内部类不能有访问说明符，因为他不是外围类的一部分，但是它可以访问当前代码块内的常量以及此外围类的所有成员。